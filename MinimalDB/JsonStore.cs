using System.Reflection;
using System.Text.Json;

using MinimalDB.Exceptions;
using MinimalDB.Extensions;

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

using JsonSerializer = System.Text.Json.JsonSerializer;

namespace MinimalDB;
public class JsonStore
{
    private readonly string _file;
    private readonly JsonSerializerOptions _jsonSerializerOptions;
    private readonly JArray _data;
    private readonly Queue<PendingCommits> _pendingChanges = new Queue<PendingCommits>();

    public JsonStore(string file)
    {
        _file = file;
        _data = JArray.Parse(FileAccess.GetJsonFromDb(_file) ?? "");
        _jsonSerializerOptions = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            PropertyNameCaseInsensitive = true
        };
    }

    public void Insert<T>(T obj) where T : class
    {
        if (obj is null)
        {
            throw new ArgumentException(nameof(obj));
        }

        var json = JsonSerializer.Serialize(obj, _jsonSerializerOptions);
        var properties = typeof(T).GetProperties();
        var idProperty = properties.FirstOrDefault(p => p.Name.Equals("id", StringComparison.OrdinalIgnoreCase));
        bool hasKey = idProperty != null;

        if (HasAutoGeneratedKey(idProperty!, json, out var nextKey))
        {
            EnsureUniqueKey(nextKey);
            AddPendingChange(CreateNewAddition(json, nextKey), DbAction.Create);
        }
        else
        {
            var key = GetKeyFromJson(idProperty!, json);
            EnsureUniqueKey(key);
            AddPendingChange(JObject.Parse(json), DbAction.Create);
        }
    }

    public ICollection<T> FindAll<T>()
    {
        return _data.ToList<T>();
    }

    public IEnumerable<T>? FindByCondition<T>(Func<T, bool> predicate)
    {
        var results = _data.ToList<T>().Where(predicate).ToList();
        if (results.Count == 0)
        {
            throw new NotFoundException($"{typeof(T)} that fits the condition does not exist!");
        }
        return results;
    }

    public bool Commit()
    {
        lock (_pendingChanges)
        {
            while (_pendingChanges.Count > 0)
            {
                var change = _pendingChanges.Dequeue();
                if (change.Action == DbAction.Create)
                {
                    CommitCreate(change.Data);
                }
            }

            return SaveDataToFile();
        }
    }

    private bool HasAutoGeneratedKey(PropertyInfo idProperty, string json, out dynamic? nextKey)
    {
        nextKey = null;

        if (idProperty != null && IsDefaultKeyValue(idProperty, json))
        {
            nextKey = GetNextKey(idProperty.PropertyType);
            return true;
        }

        return false;
    }

    private static bool IsDefaultKeyValue(PropertyInfo idProperty, string json)
    {
        var keyValue = JObject.Parse(json)["id"];
        return (idProperty.PropertyType == typeof(int) && (int)keyValue! == 0) ||
               (idProperty.PropertyType == typeof(Guid) && (Guid)keyValue! == Guid.Empty);
    }

    private dynamic GetNextKey(Type propertyType)
    {
        if (propertyType == typeof(int))
        {
            return GetNextIntKey();
        }
        if (propertyType == typeof(Guid))
        {
            return Guid.NewGuid();
        }
        return Guid.NewGuid().ToString();
    }

    private int GetNextIntKey()
    {
        if (!_data.Children().Any() && !_pendingChanges.Any(c => c.Action == DbAction.Create))
        {
            return 1;
        }

        var lastDbId = _data.Children().Any() ? (int)_data?.Last!["id"]! : 0;
        var lastPendingId = _pendingChanges.LastOrDefault(c => c.Action == DbAction.Create)?.Data["id"];

        var nextDbKey = lastDbId + 1;
        var nextPendingKey = lastPendingId != null ? (int)lastPendingId + 1 : 1;

        return Math.Max(nextDbKey, nextPendingKey);
    }

    private static dynamic GetKeyFromJson(PropertyInfo idProperty, string json)
    {
        var keyValue = JObject.Parse(json)["id"];
        return idProperty?.PropertyType == typeof(Guid) ? (Guid)keyValue! : keyValue!;
    }

    private void EnsureUniqueKey(dynamic key)
    {
        if (_data.Any(x => (dynamic)x["id"]! == key) || _pendingChanges.Any(x => (dynamic)x.Data["id"]! == key))
        {
            throw new DuplicateKeyException($"Item with Id {key} already exists!");
        }
    }

    private static JObject CreateNewAddition(string json, dynamic nextKey)
    {
        var newAddition = JObject.Parse(json);
        newAddition["id"] = nextKey;
        return newAddition;
    }

    private void AddPendingChange(JObject data, DbAction action)
    {
        _pendingChanges.Enqueue(new PendingCommits(data, action));
    }

    private void CommitCreate(JObject newAddition)
    {
        _data.Add(newAddition);
    }

    private bool SaveDataToFile()
    {
        try
        {
            FileAccess.WriteJsonToDb(_file, _data.ToString(Formatting.None));
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            return false;
        }
    }

    private enum DbAction
    {
        Create, Update, Delete
    }

    private record PendingCommits(JObject Data, DbAction Action);
}
